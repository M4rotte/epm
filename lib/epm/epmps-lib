#!/bin/sh
# /lib/epm/epmps-lib

# $EPM_DB_SEP: field separator
# NB: Fields separated by this separator are:
#      - `$(date +%s)`
#      - `ps -o user,group,comm,pid,ppid,pgid,etime,nice,rgroup,ruser,time,tty,vsz,stat,rss,args | awk '{ if ($4 == '"$1"') { print $0 } }'`
# The ps’s output values which compose the second field are separated by spaces.

filter_pid() { awk -v pid="$1" -v ORS= '$1 == pid{$1=$1; print}'; }

ps_store_current_info() {
    # ps_store_info(pid,service)
    # Write the ps output prefixed with time, which corresponds to this pid, in a file named <service name>.pid in $EPM_RUN_DIR,
    # With with the default settings it’s /var/run/<service name>.pid
    printf "$(date +%s)$EPM_DB_SEP" >> "$EPM_RUN_DIR/$2.pid"
    ps -e -o pid,ppid,user,group,comm,pgid,etime,nice,rgroup,ruser,time,tty,vsz,stat,rss,args |\
        filter_pid $1 >> "$EPM_RUN_DIR/$2.pid"
    printf "\n" >> "$EPM_RUN_DIR/$2.pid"
}

args_store_current_info() {
    # ps_store_info(args,service)
    # Write the ps output prefixed with time, which corresponds to thiose args, in a file named <service name>.pid in $EPM_RUN_DIR,
    # With with the default settings it’s /var/run/<service name>.pid
    printf "$(date +%s)$EPM_DB_SEP" >> "$EPM_RUN_DIR/$2.pid"
    grep_re='^.* '"$1"'$'
    ps -e -o pid,ppid,user,group,comm,pgid,etime,nice,rgroup,ruser,time,tty,vsz,stat,rss,args |\
        grep -E "$grep_re" >> "$EPM_RUN_DIR/$2.pid" >> "$EPM_RUN_DIR/$2.pid"
}

ps_write_log() {
    # ps_write_log(message,service)
    printf "$(date +%Is) "
    echo "$1" >> "$EPM_LOG_DIR/$2.log"
}

ps_get_last_info() {
    # ps_get_last_info(service)
    tail -n1 "$EPM_RUN_DIR/$1.pid" 2>/dev/null
}

ps_get_last_args() {
    # ps_get_last_args(service)
    ps_get_last_info "$1" | awk '{for(i=1;i<=NF;i++){printf "%s ", $i}; printf "\n"}' | cut -d' ' -f 16-
}

sv_get_start_cmd() {
    # ps_get_start_cmd(service)
    grep_re='^StartCmd.*\s+.*$'
    start_cmd="$(grep -E "$grep_re" "$EPM_SERVICES_DIR/${1}${EPM_SERVICEFILE_EXT}" 2>/dev/null |awk '{$1=""; gsub(/^[ \t]+/,"",$0)}1')"
    [ -n "$start_cmd" ] || start_cmd="$(which "$1")"
    echo "$start_cmd"
}

sv_get_desired_state() {
    # sv_get_desired_state(service)
    grep_re='^DesiredState.*\s+.*$'
    desired_state="$(grep -E "$grep_re" "$EPM_SERVICES_DIR/${1}${EPM_SERVICEFILE_EXT}" 2>/dev/null |awk '{$1=""; gsub(/^[ \t]+/,"",$0)}1')"
    [ -n "$desired_state" ] || desired_state='running'
    echo "$desired_state"
}

sv_is_running() {
    # sv_is_running(service)
    service_pids="$(sv_pids "$1")"
    [ -n "$service_pids" ]
}

sv_pids() {
    # sv_pids(service)
    start_cmd="$(sv_get_start_cmd "$1")"
    grep_filter='^.* '"$start_cmd"'$'
    ps -e -o pid,args | grep -E "$grep_filter" |awk '{print $1}'
}

sv_is_managed() { [ -f "$EPM_SERVICES_DIR/$1$EPM_SERVICEFILE_EXT" ]; }

sv_prescription() {
    ! sv_is_running "$1" && [ "$3" = 'running' ] && {
        write_log "Service \"$1\" should be running…"
        prescription="$(sv_get_start_cmd "$1")"
    }
    sv_is_running "$1" && [ "$3" = 'stopped' ] && {
        write_log "Service \"$1\" should be stopped…"
        prescription="kill -15 -- -$service_pids"
    }
    echo $prescription
}
