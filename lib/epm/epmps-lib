#!/bin/sh
# /lib/epm/epmps-lib

# $EPM_DB_SEP: field separator
# NB: Fields separated by this separator are:
#      - `$(date +%s)`
#      - `ps -o pid,ppid,user,group,pgid,etime,nice,rgroup,ruser,time,tty,vsz,stat,rss,comm,args | awk '{ if ($4 == '"$1"') { print $0 } }'`
# The ps’s output values which compose the second field are separated by spaces.

filter_pid() { awk -v pid="$1" -v ORS= '$1 == pid{$1=$1; print}'; }

ps_store_current_info() {
    # ps_store_info(pid,service)
    # Write the ps output prefixed with time, which corresponds to this pid, in a file named <service name>.pid in $EPM_RUN_DIR,
    # With with the default settings it’s /var/run/<service name>.pid
    info="$(ps -e -o pid,ppid,user,group,pgid,etime,nice,rgroup,ruser,time,tty,vsz,stat,rss,comm,args | filter_pid $1)"
    echo "PROC STORE ($2:$1): $info" >&2
    [ -n "$info" ] && printf "%s\n" "$(date +%s)${EPM_DB_SEP}${info}" >> "$EPM_RUN_DIR/$2.pid"
}

args_store_current_info() {
    # ps_store_info(args,service)
    # Write the ps output prefixed with time, which corresponds to thiose args, in a file named <service name>.pid in $EPM_RUN_DIR,
    # With with the default settings it’s /var/run/<service name>.pid
    grep_re='^.* '"$1"'$'
    info="$(ps -e -o pid,ppid,user,group,pgid,etime,nice,rgroup,ruser,time,tty,vsz,stat,rss,comm,args | grep -E "$grep_re" | sed -e 's/  */ /g')"
    echo "ARGS STORE ($2:$1): $info" >&2
    [ -n "$info" ] && printf "%s\n" "$(date +%s)${EPM_DB_SEP}${info}" >> "$EPM_RUN_DIR/$2.pid"
}

ps_write_log() {
    # ps_write_log(message,service)
    printf "$(date +%Is) "
    echo "$1" >> "$EPM_LOG_DIR/$2.log"
}

ps_get_last_info() {
    # ps_get_last_info(service)
    tail -n1 "$EPM_RUN_DIR/$1.pid" 2>/dev/null
}

ps_get_last_args() {
    # ps_get_last_args(service)
    ps_get_last_info "$1" | awk '{for(i=1;i<=NF;i++){printf "%s ", $i}; printf "\n"}' | cut -d' ' -f 16-
}

sv_get_start_cmd() {
    # ps_get_start_cmd(service)
    grep_re='^StartCmd\s+.*$'
    start_cmd="$(grep -E "$grep_re" "$EPM_SERVICES_DIR/${1}${EPM_SERVICEFILE_EXT}" 2>/dev/null |awk '{$1=""; gsub(/^[ \t]+/,"",$0)}1')"
    [ -n "$start_cmd" ] || start_cmd="$(which "$1")"
    echo "$start_cmd"
}

sv_get_comm() {
    # ps_get_comm(service)
    grep_re='^Command\s+.*$'
    command="$(grep -E "$grep_re" "$EPM_SERVICES_DIR/${1}${EPM_SERVICEFILE_EXT}" 2>/dev/null |awk '{$1=""; gsub(/^[ \t]+/,"",$0)}1')"
    echo "$command"
}

sv_get_desired_state() {
    # sv_get_desired_state(service)
    grep_re='^DesiredState\s+.*$'
    desired_state="$(grep -E "$grep_re" "$EPM_SERVICES_DIR/${1}${EPM_SERVICEFILE_EXT}" 2>/dev/null |awk '{$1=""; gsub(/^[ \t]+/,"",$0)}1')"
    [ -n "$desired_state" ] || desired_state='running'
    echo "$desired_state"
}

sv_pids() {
    # sv_pids(service)
    start_cmd="$(sv_get_start_cmd "$1")"
    echo StartCmd: $start_cmd >&2
    grep_filter='^.* '"$start_cmd"'$'
    echo Filter  : $grep_filter >&2
    ps -e -o pid,args | grep -E "$grep_filter" | awk '{print $1}'
}

sv_pids_by_command() {
    #sv_pids_by_command(command)
    ps -e -o pid,comm | grep "$1" | awk '{print $1}'
}

sv_is_running() {
    # sv_is_running(service)
    command="$(sv_get_comm "$1")"
    echo Command : $command >&2
    if [ -z "$command" ]; then service_pids="$(sv_pids "$1")"
    else service_pids="$(sv_pids_by_command "$command")"; fi
    [ -n "$service_pids" ]
}

sv_is_managed() { [ -f "$EPM_SERVICES_DIR/$1$EPM_SERVICEFILE_EXT" ]; }

sv_prescription() {
    start_cmd="$(sv_get_start_cmd "$1")"
    ! sv_is_running "$1" && [ "$3" = 'running' ] && {
        write_log "Service \"$1\" should be running…"
        args_store_current_info "$start_cmd" "$1"
        prescription="$start_cmd"
    }
    sv_is_running "$1" && [ "$3" = 'stopped' ] && {
        write_log "Service \"$1\" should be stopped…"
        args_store_current_info "$start_cmd" "$1"
        prescription="kill -15 -- -$service_pids"
    }
    sv_is_running "$1" && [ "$3" = 'running' ] && {
        args_store_current_info "$start_cmd" "$1"
        prescription=''
    }
    echo $prescription
}
